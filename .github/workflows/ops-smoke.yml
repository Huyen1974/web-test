name: ops-smoke

on:
  schedule:
    - cron: '0 */6 * * *' # Every 6 hours
  workflow_dispatch:

env:
  DIRECTUS_BASE_URL: ${{ vars.DIRECTUS_BASE_URL || vars.NUXT_PUBLIC_DIRECTUS_URL || secrets.DIRECTUS_BASE_URL || secrets.NUXT_PUBLIC_DIRECTUS_URL }}
  # GCS switch 2025-12-23 â€“ persistent public assets
  # Updated 2026-01-06 after schema migration
  SMOKE_ASSET_ID: "b18f3792-bd31-43e5-8a7d-b25d76f41dd9"

jobs:
  smoke-test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Health Check with Cold Start Tolerance
        env:
          DIRECTUS_URL: ${{ env.DIRECTUS_BASE_URL }}
          MAX_WAIT_SECONDS: 600
          RETRY_INTERVAL: 15
          SMOKE_ASSET_ID: ${{ env.SMOKE_ASSET_ID }}
        run: |
          echo "ðŸ”¹ Starting health check with cold start tolerance..."
          if [ -z "$DIRECTUS_URL" ]; then
            echo "âš ï¸  DIRECTUS_URL is empty (check repo variables). Polling will continue until timeout."
          fi
          echo "   Max wait: ${MAX_WAIT_SECONDS}s"
          echo "   Retry interval: ${RETRY_INTERVAL}s"
          echo ""

          HEALTH_URL="${DIRECTUS_URL}/server/health"
          PAGES_URL="${DIRECTUS_URL}/items/pages?filter[permalink][_eq]=/"
          ASSET_URL="${DIRECTUS_URL}/assets/${SMOKE_ASSET_ID}"

          START_TIME=$(date +%s)
          ATTEMPT=1
          LAST_HEALTH="000"
          LAST_PAGES="000"
          LAST_ASSET="000"

          classify_status() {
            case "$1" in
              200) echo "healthy" ;;
              500|502|503|504) echo "startup noise" ;;
              000) echo "no response yet" ;;
              *) echo "real failure (still waiting)" ;;
            esac
          }

          log_status() {
            local label="$1"
            local code="$2"
            echo "   ${label} Status: ${code} ($(classify_status "$code"))"
          }

          while true; do
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - START_TIME))

            if [ $ELAPSED -ge $MAX_WAIT_SECONDS ]; then
              echo "âŒ TIMEOUT: Service did not become healthy within ${MAX_WAIT_SECONDS}s"
              echo "   Last health: ${LAST_HEALTH}, pages: ${LAST_PAGES}, asset: ${LAST_ASSET}"
              exit 1
            fi

            echo "Attempt $ATTEMPT (${ELAPSED}s elapsed)..."
            LAST_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              "$HEALTH_URL" 2>/dev/null || echo "000")
            log_status "Health" "$LAST_HEALTH"

            if [ "$LAST_HEALTH" = "200" ]; then
              LAST_PAGES=$(curl --globoff -s -o /dev/null -w "%{http_code}" \
                --connect-timeout 10 --max-time 30 \
                "$PAGES_URL" 2>/dev/null || echo "000")
              log_status "Pages" "$LAST_PAGES"

              LAST_ASSET=$(curl -sS -L -A "Mozilla/5.0 (ops-smoke)" \
                --connect-timeout 10 --max-time 30 \
                -D /tmp/asset_headers.txt \
                -o /tmp/asset_body.txt \
                -w "%{http_code}" \
                "$ASSET_URL" 2>/dev/null || echo "000")
              log_status "Asset" "$LAST_ASSET"

              if [ "$LAST_PAGES" = "200" ] && [ "$LAST_ASSET" = "200" ]; then
                echo "âœ… SUCCESS: Service is healthy!"
                echo "   Total time: ${ELAPSED}s"
                break
              fi
            else
              echo "   Waiting for health endpoint to return 200..."
            fi

            ATTEMPT=$((ATTEMPT + 1))
            sleep "$RETRY_INTERVAL"
          done

          echo ""
          echo "âœ… SMOKE TEST PASSED"
