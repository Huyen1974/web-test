#!/usr/bin/env bash
# dot-sync-check: Verify sync status between Local and Cloud Directus
# Usage: ./dot/bin/dot-sync-check [--verbose]
set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

# URLs
LOCAL_URL="${LOCAL_DIRECTUS_URL:-http://localhost:8055}"
CLOUD_URL="${CLOUD_DIRECTUS_URL:-https://directus-test-pfne2mqwja-as.a.run.app}"
WEBSITE_URL="${WEBSITE_URL:-https://ai.incomexsaigoncorp.vn}"

# Auth credentials (from env - NO DEFAULTS for security)
# Priority: DIRECTUS_STATIC_TOKEN > email/password login
STATIC_TOKEN="${DIRECTUS_STATIC_TOKEN:-}"
ADMIN_EMAIL="${DIRECTUS_ADMIN_EMAIL:-}"
ADMIN_PASSWORD="${DIRECTUS_ADMIN_PASSWORD:-}"

# SECURITY: Require static token in CI (no fallback to login)
if [ -z "$STATIC_TOKEN" ]; then
  if [ -n "${CI:-}" ] || [ -n "${GITHUB_ACTIONS:-}" ]; then
    echo -e "${RED}❌ SECURITY ERROR: DIRECTUS_STATIC_TOKEN is required in CI${NC}"
    echo "   Token must be retrieved from Google Secret Manager"
    echo "   Check WIF authentication and GSM permissions"
    exit 1
  fi
  # Only allow email/password login for LOCAL development
  if [ -n "$ADMIN_EMAIL" ] && [ -n "$ADMIN_PASSWORD" ]; then
    echo -e "${YELLOW}⚠️  WARNING: Using login credentials (local dev only)${NC}"
  fi
fi

# Verbose mode
VERBOSE=false
[[ "${1:-}" == "--verbose" || "${1:-}" == "-v" ]] && VERBOSE=true

# Get auth token (use temp file to avoid shell escaping issues)
get_token() {
    local url="$1"
    local tmpfile=$(mktemp)
    cat > "$tmpfile" << EOFLOGIN
{"email":"$ADMIN_EMAIL","password":"$ADMIN_PASSWORD"}
EOFLOGIN
    local token=$(curl -s --max-time 10 -X POST "$url/auth/login" \
        -H "Content-Type: application/json" \
        -d @"$tmpfile" 2>/dev/null \
        | grep -o '"access_token":"[^"]*"' \
        | cut -d'"' -f4)
    rm -f "$tmpfile"
    echo "$token"
}

# Show help
if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
    echo "DOT-SYNC-CHECK - Verify Local ↔ Cloud Directus sync"
    echo ""
    echo "Usage: dot-sync-check [--verbose]"
    echo ""
    echo "Options:"
    echo "  -v, --verbose  Show detailed field comparison on drift"
    echo "  -h, --help     Show this help"
    echo ""
    echo "Environment:"
    echo "  DIRECTUS_STATIC_TOKEN  Use static token (priority over login)"
    echo "  DIRECTUS_ADMIN_EMAIL   Admin email for login"
    echo "  DIRECTUS_ADMIN_PASSWORD Admin password for login"
    echo "  LOCAL_DIRECTUS_URL     Local Directus URL"
    echo "  CLOUD_DIRECTUS_URL     Cloud Directus URL"
    echo ""
    echo "Checks:"
    echo "  1. Local Directus health"
    echo "  2. Cloud Directus health"
    echo "  3. Schema sync (hash comparison)"
    echo "  4. Anonymous read (Local)"
    echo "  5. Anonymous read (Cloud)"
    echo "  6. Website production"
    exit 0
fi

echo "======================================"
echo "  DOT Sync Check - Local ↔ Cloud"
echo "======================================"
echo ""
echo "Local:   $LOCAL_URL"
echo "Cloud:   $CLOUD_URL"
echo "Website: $WEBSITE_URL"
if [ -n "$STATIC_TOKEN" ]; then
    echo "Auth:    Static Token (from env)"
else
    echo "Auth:    Login ($ADMIN_EMAIL)"
fi
echo ""

ERRORS=0
WARNINGS=0

# Helper: get sorted field list and compute hash (SHA1 via shasum)
get_fields_hash() {
    local url="$1"
    local collection="$2"
    local token="$3"
    curl -s --max-time 10 "$url/fields/$collection" \
        -H "Authorization: Bearer $token" 2>/dev/null \
        | grep -o '"field":"[^"]*"' \
        | cut -d'"' -f4 \
        | sort \
        | shasum 2>/dev/null | cut -d' ' -f1 || echo "error"
}

# Helper: get sorted field list as comma-separated
get_fields_list() {
    local url="$1"
    local collection="$2"
    local token="$3"
    curl -s --max-time 10 "$url/fields/$collection" \
        -H "Authorization: Bearer $token" 2>/dev/null \
        | grep -o '"field":"[^"]*"' \
        | cut -d'"' -f4 \
        | sort \
        | tr '\n' ',' \
        | sed 's/,$//'
}

# Helper: count fields
get_fields_count() {
    local url="$1"
    local collection="$2"
    local token="$3"
    curl -s --max-time 10 "$url/fields/$collection" \
        -H "Authorization: Bearer $token" 2>/dev/null \
        | grep -o '"field":"[^"]*"' \
        | wc -l \
        | tr -d ' '
}

# --- Check 1: Local Directus Health ---
echo -n "1. Local Directus health.......... "
LOCAL_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$LOCAL_URL/server/health" 2>/dev/null || echo "000")
if [ "$LOCAL_HEALTH" == "200" ]; then
    echo -e "${GREEN}✅ OK${NC}"
else
    echo -e "${RED}❌ FAIL (HTTP $LOCAL_HEALTH)${NC}"
    ((ERRORS++))
fi

# --- Check 2: Cloud Directus Health ---
echo -n "2. Cloud Directus health.......... "
CLOUD_HEALTH=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "$CLOUD_URL/server/health" 2>/dev/null || echo "000")
if [ "$CLOUD_HEALTH" == "200" ]; then
    echo -e "${GREEN}✅ OK${NC}"
else
    echo -e "${RED}❌ FAIL (HTTP $CLOUD_HEALTH)${NC}"
    ((ERRORS++))
fi

# --- Check 3: Schema Sync (hash comparison) ---
echo -n "3. Schema sync (knowledge_documents)... "
if [ "$LOCAL_HEALTH" == "200" ] && [ "$CLOUD_HEALTH" == "200" ]; then
    # Get auth tokens - use static token if available, otherwise login
    if [ -n "$STATIC_TOKEN" ]; then
        LOCAL_TOKEN="$STATIC_TOKEN"
        CLOUD_TOKEN="$STATIC_TOKEN"
    else
        LOCAL_TOKEN=$(get_token "$LOCAL_URL")
        CLOUD_TOKEN=$(get_token "$CLOUD_URL")
    fi

    if [ -z "$LOCAL_TOKEN" ] || [ -z "$CLOUD_TOKEN" ]; then
        echo -e "${YELLOW}⚠️  AUTH FAILED (check credentials)${NC}"
        ((WARNINGS++))
    else
        LOCAL_HASH=$(get_fields_hash "$LOCAL_URL" "knowledge_documents" "$LOCAL_TOKEN")
        CLOUD_HASH=$(get_fields_hash "$CLOUD_URL" "knowledge_documents" "$CLOUD_TOKEN")
        LOCAL_COUNT=$(get_fields_count "$LOCAL_URL" "knowledge_documents" "$LOCAL_TOKEN")

        if [ "$LOCAL_HASH" == "$CLOUD_HASH" ]; then
            echo -e "${GREEN}✅ SYNCED ($LOCAL_COUNT fields, hash match)${NC}"
        else
            echo -e "${RED}❌ DRIFT (hash mismatch)${NC}"
            if $VERBOSE; then
                echo -e "   ${CYAN}Local fields:${NC}"
                echo "   $(get_fields_list "$LOCAL_URL" "knowledge_documents" "$LOCAL_TOKEN")"
                echo -e "   ${CYAN}Cloud fields:${NC}"
                echo "   $(get_fields_list "$CLOUD_URL" "knowledge_documents" "$CLOUD_TOKEN")"
            else
                echo -e "   ${YELLOW}Run with --verbose to see field diff${NC}"
            fi
            ((ERRORS++))
        fi
    fi
else
    echo -e "${YELLOW}⏭️  SKIPPED (one or both instances down)${NC}"
    ((WARNINGS++))
fi

# --- Check 4: Anonymous Read (Local) ---
echo -n "4. Anonymous read (Local)......... "
if [ "$LOCAL_HEALTH" == "200" ]; then
    LOCAL_READ=$(curl -s -o /dev/null -w "%{http_code}" --max-time 5 "$LOCAL_URL/items/knowledge_documents?limit=1" 2>/dev/null || echo "000")
    if [ "$LOCAL_READ" == "200" ]; then
        echo -e "${GREEN}✅ OK${NC}"
    else
        echo -e "${YELLOW}⚠️  BLOCKED (HTTP $LOCAL_READ)${NC}"
        ((WARNINGS++))
    fi
else
    echo -e "${YELLOW}⏭️  SKIPPED${NC}"
fi

# --- Check 5: Anonymous Read (Cloud) ---
echo -n "5. Anonymous read (Cloud)......... "
if [ "$CLOUD_HEALTH" == "200" ]; then
    CLOUD_READ=$(curl -s -o /dev/null -w "%{http_code}" --max-time 15 "$CLOUD_URL/items/knowledge_documents?limit=1" 2>/dev/null || echo "000")
    if [ "$CLOUD_READ" == "200" ]; then
        echo -e "${GREEN}✅ OK${NC}"
    else
        echo -e "${YELLOW}⚠️  BLOCKED (HTTP $CLOUD_READ)${NC}"
        ((WARNINGS++))
    fi
else
    echo -e "${YELLOW}⏭️  SKIPPED${NC}"
fi

# --- Check 6: Website (Production) ---
echo -n "6. Website (/knowledge)........... "
WEB_CHECK=$(curl -s -o /dev/null -w "%{http_code}" --max-time 20 "$WEBSITE_URL/knowledge" 2>/dev/null || echo "000")
if [ "$WEB_CHECK" == "200" ]; then
    echo -e "${GREEN}✅ OK${NC}"
else
    echo -e "${RED}❌ FAIL (HTTP $WEB_CHECK)${NC}"
    ((ERRORS++))
fi

# --- Summary ---
echo ""
echo "======================================"
if [ "$ERRORS" -eq 0 ] && [ "$WARNINGS" -eq 0 ]; then
    echo -e "${GREEN}  ALL CHECKS PASSED ✅${NC}"
    exit 0
elif [ "$ERRORS" -eq 0 ]; then
    echo -e "${YELLOW}  PASSED WITH $WARNINGS WARNING(S) ⚠️${NC}"
    exit 0
else
    echo -e "${RED}  $ERRORS CHECK(S) FAILED ❌${NC}"
    [ "$WARNINGS" -gt 0 ] && echo -e "${YELLOW}  $WARNINGS WARNING(S) ⚠️${NC}"
    exit 1
fi
