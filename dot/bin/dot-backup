#!/usr/bin/env node

/**
 * DOT Backup - Export Directus data to JSON files
 *
 * Exports business collections to JSON for backup/restore purposes.
 * Does NOT export system tables (directus_*).
 *
 * Usage:
 *   ./dot/bin/dot-backup [options]
 *
 * Options:
 *   --output-dir  Custom output directory (default: dot/backups/YYYY-MM-DD)
 *   --help        Show this help
 */

const path = require('path');
const fs = require('fs');
const https = require('https');
const http = require('http');

// Collections to backup (business data only)
const BACKUP_COLLECTIONS = [
  'os_projects',
  'os_tasks',
  'os_invoices',
  'contacts',
  'agency_services',
  'agency_team_members',
  'agency_about',
  'globals',
  'pages',
  'posts',
];

const { execSync } = require('child_process');

// Parse arguments
const args = process.argv.slice(2);
const options = {
  help: args.includes('--help') || args.includes('-h'),
  local: args.includes('--local'),
  cloud: args.includes('--cloud'),
  outputDir: null,
};

const outputIdx = args.indexOf('--output-dir');
if (outputIdx !== -1 && args[outputIdx + 1]) {
  options.outputDir = args[outputIdx + 1];
}

if (options.help) {
  console.log(`
DOT Backup - Export Directus data to JSON files

Usage:
  ./dot/bin/dot-backup [options]

Options:
  --local           Use local development environment
  --cloud           Use cloud/production environment (default)
  --output-dir DIR  Custom output directory (default: dot/backups/YYYY-MM-DD)
  --help, -h        Show this help

Environment Variables:
  DIRECTUS_URL            Directus API URL
  DIRECTUS_ADMIN_EMAIL    Admin email
  DIRECTUS_ADMIN_PASSWORD Admin password
`);
  process.exit(0);
}

// Environment detection
function detectEnvironment() {
  if (options.local) return 'local';
  if (options.cloud) return 'cloud';
  if (process.env.DOT_ENV === 'local') return 'local';
  if (process.env.DOT_ENV === 'cloud') return 'cloud';

  // Auto-detect
  try {
    execSync('curl -sf --max-time 1 http://localhost:8055/server/health', {
      stdio: 'pipe',
    });
    return 'local';
  } catch {
    return 'cloud';
  }
}

const ENV = detectEnvironment();
const LOCAL_DIRECTUS_URL = 'http://localhost:8055';
const CLOUD_DIRECTUS_URL = 'https://directus.incomexsaigoncorp.vn';

// Print environment banner
function printEnvironmentBanner(directusUrl) {
  console.log('');
  if (ENV === 'local') {
    console.log('\x1b[32m\x1b[1mâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\x1b[0m');
    console.log('\x1b[32m\x1b[1mâ”‚  ðŸŸ¢ LOCAL MODE                                      â”‚\x1b[0m');
    console.log(`\x1b[32m\x1b[1mâ”‚     Directus: ${directusUrl.padEnd(37)}â”‚\x1b[0m`);
    console.log('\x1b[32m\x1b[1mâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\x1b[0m');
  } else {
    console.log('\x1b[31m\x1b[1mâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\x1b[0m');
    console.log('\x1b[31m\x1b[1mâ”‚  ðŸ”´ CLOUD MODE (PRODUCTION)                         â”‚\x1b[0m');
    console.log(`\x1b[31m\x1b[1mâ”‚     Directus: ${directusUrl}â”‚\x1b[0m`);
    console.log('\x1b[31m\x1b[1mâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\x1b[0m');
  }
  console.log('');
}

// Load credentials
function loadConfig() {
  const configDir = path.resolve(__dirname, '../config');
  const localPath = path.resolve(configDir, 'credentials.local.json');
  const projectRoot = path.resolve(__dirname, '../..');
  const envLocalPath = path.resolve(projectRoot, '.env.local');

  // Determine default URL based on environment
  const defaultUrl = ENV === 'local' ? LOCAL_DIRECTUS_URL : CLOUD_DIRECTUS_URL;

  let config = {
    directusUrl: process.env.DIRECTUS_URL || defaultUrl,
    email: process.env.DIRECTUS_ADMIN_EMAIL || 'admin@example.com',
    password: process.env.DIRECTUS_ADMIN_PASSWORD,
  };

  // For local mode, try .env.local first
  if (ENV === 'local' && fs.existsSync(envLocalPath)) {
    try {
      const envContent = fs.readFileSync(envLocalPath, 'utf-8');
      const emailMatch = envContent.match(/^DIRECTUS_ADMIN_EMAIL=(.+)$/m);
      const passMatch = envContent.match(/^DIRECTUS_ADMIN_PASSWORD=(.+)$/m);
      if (emailMatch) config.email = emailMatch[1];
      if (passMatch) config.password = passMatch[1];
    } catch (e) {
      // Ignore
    }
  }

  // Try credentials.local.json as fallback
  if (!config.password && fs.existsSync(localPath)) {
    try {
      const creds = JSON.parse(fs.readFileSync(localPath, 'utf-8'));
      const profile = creds.profiles?.[0];
      if (profile) {
        config.email = config.email || profile.username;
        config.password = config.password || profile.password;
        config.directusUrl = config.directusUrl || creds.directusUrl;
      }
    } catch (e) {
      // Ignore parse errors
    }
  }

  if (!config.password) {
    console.error('Error: DIRECTUS_ADMIN_PASSWORD is required');
    console.error('For local mode: ensure .env.local exists');
    console.error('For cloud mode: set DIRECTUS_ADMIN_PASSWORD env var');
    process.exit(1);
  }

  return config;
}

// HTTP request helper
function request(url, options = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const client = urlObj.protocol === 'https:' ? https : http;

    const req = client.request(url, {
      method: options.method || 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          resolve({ status: res.statusCode, data: JSON.parse(data) });
        } catch {
          resolve({ status: res.statusCode, data });
        }
      });
    });

    req.on('error', reject);
    if (options.body) req.write(JSON.stringify(options.body));
    req.end();
  });
}

async function main() {
  const config = loadConfig();
  const timestamp = new Date().toISOString().split('T')[0];
  const backupDir = options.outputDir || path.resolve(__dirname, `../backups/${timestamp}`);

  console.log('\n\x1b[36m\x1b[1m  DOT BACKUP\x1b[0m');
  printEnvironmentBanner(config.directusUrl);
  console.log(`Output: ${backupDir}\n`);

  // Create backup directory
  fs.mkdirSync(backupDir, { recursive: true });

  // Authenticate
  console.log('\x1b[33m[AUTH]\x1b[0m Logging in...');
  const authRes = await request(`${config.directusUrl}/auth/login`, {
    method: 'POST',
    body: { email: config.email, password: config.password },
  });

  if (!authRes.data?.data?.access_token) {
    console.error('\x1b[31m[ERROR]\x1b[0m Authentication failed');
    process.exit(1);
  }

  const token = authRes.data.data.access_token;
  console.log('\x1b[32m[AUTH]\x1b[0m Success\n');

  // Get available collections
  const collectionsRes = await request(`${config.directusUrl}/collections`, {
    headers: { Authorization: `Bearer ${token}` },
  });

  const availableCollections = collectionsRes.data?.data?.map(c => c.collection) || [];

  // Backup each collection
  const results = { success: [], skipped: [], failed: [] };
  const manifest = {
    timestamp: new Date().toISOString(),
    directusUrl: config.directusUrl,
    collections: {},
  };

  for (const collection of BACKUP_COLLECTIONS) {
    if (!availableCollections.includes(collection)) {
      console.log(`\x1b[33m[SKIP]\x1b[0m ${collection} - not found`);
      results.skipped.push(collection);
      continue;
    }

    try {
      const res = await request(`${config.directusUrl}/items/${collection}?limit=-1`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      if (res.status === 200 && res.data?.data) {
        const items = res.data.data;
        const filePath = path.join(backupDir, `${collection}.json`);
        fs.writeFileSync(filePath, JSON.stringify(items, null, 2));
        console.log(`\x1b[32m[OK]\x1b[0m ${collection} - ${items.length} items`);
        results.success.push(collection);
        manifest.collections[collection] = { count: items.length, file: `${collection}.json` };
      } else {
        console.log(`\x1b[31m[FAIL]\x1b[0m ${collection} - HTTP ${res.status}`);
        results.failed.push(collection);
      }
    } catch (err) {
      console.log(`\x1b[31m[FAIL]\x1b[0m ${collection} - ${err.message}`);
      results.failed.push(collection);
    }
  }

  // Write manifest
  fs.writeFileSync(path.join(backupDir, 'manifest.json'), JSON.stringify(manifest, null, 2));

  // Summary
  console.log('\n\x1b[1m SUMMARY\x1b[0m\n');
  console.log(`Backup location: ${backupDir}`);
  console.log(`\x1b[32mSuccess:\x1b[0m ${results.success.length}`);
  console.log(`\x1b[33mSkipped:\x1b[0m ${results.skipped.length}`);
  console.log(`\x1b[31mFailed:\x1b[0m ${results.failed.length}`);

  if (results.failed.length > 0) {
    process.exit(1);
  }
}

main().catch(err => {
  console.error('\x1b[31m[ERROR]\x1b[0m', err.message);
  process.exit(1);
});
