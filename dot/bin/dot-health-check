#!/usr/bin/env node
'use strict'

const dns = require('node:dns').promises
const { URL } = require('node:url')
const { execSync } = require('node:child_process')

// Retry configuration from environment
const RETRY_MAX = parseInt(process.env.DOT_RETRY_MAX || '3', 10)
const RETRY_TIMEOUT = parseInt(process.env.DOT_RETRY_TIMEOUT || '30', 10) * 1000 // ms
const RETRY_DELAY = parseInt(process.env.DOT_RETRY_DELAY || '5', 10) * 1000 // ms
const RETRY_BACKOFF = parseInt(process.env.DOT_RETRY_BACKOFF || '2', 10)
const RETRY_VERBOSE = process.env.DOT_RETRY_VERBOSE !== '0'

// Parse command line arguments
const args = process.argv.slice(2)
const isLocal = args.includes('--local')
const isCloud = args.includes('--cloud')
const showHelp = args.includes('--help') || args.includes('-h')
const isVerbose = args.includes('--verbose') || args.includes('-v')

if (showHelp) {
  console.log(`
DOT-HEALTH-CHECK - Check system health across all layers

Usage:
  dot-health-check [options]

Options:
  --local       Use local development environment (localhost:3000)
  --cloud       Use cloud/production environment (default)
  --verbose, -v Show detailed retry information
  --help, -h    Show this help message

Layers Checked:
  1. Network (DNS) - Hostname resolution
  2. Web Server    - HTTP response
  3. API Proxy     - Directus health endpoint
  4. Auth Flow     - Login and session cookie

Cold Start Protection:
  This tool automatically retries failed requests to handle Cloud Run cold starts.
  Configure via environment variables:
    DOT_RETRY_MAX=3       Max retry attempts (default: 3)
    DOT_RETRY_TIMEOUT=30  Timeout per attempt in seconds (default: 30)
    DOT_RETRY_DELAY=5     Initial delay between retries (default: 5)
    DOT_RETRY_BACKOFF=2   Backoff multiplier (default: 2)
`)
  process.exit(0)
}

// Colors
const colors = {
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m',
  bold: '\x1b[1m',
}

function retryLog(level, ...args) {
  if (!RETRY_VERBOSE && !isVerbose) return
  const prefix = {
    INFO: `${colors.cyan}[RETRY]${colors.reset}`,
    WARN: `${colors.yellow}[RETRY]${colors.reset}`,
    ERROR: `${colors.red}[RETRY]${colors.reset}`,
    OK: `${colors.green}[RETRY]${colors.reset}`,
  }
  console.log(prefix[level] || '[RETRY]', ...args)
}

// Sleep helper
const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms))

// Fetch with retry for cold start protection
async function fetchWithRetry(url, options = {}) {
  let lastError = null
  let delay = RETRY_DELAY

  for (let attempt = 1; attempt <= RETRY_MAX; attempt++) {
    if (attempt > 1) {
      retryLog('INFO', `Attempt ${attempt}/${RETRY_MAX} (waiting ${delay / 1000}s for cold start...)`)
    }

    const controller = new AbortController()
    const timeoutId = setTimeout(() => controller.abort(), RETRY_TIMEOUT)

    try {
      const response = await fetch(url, {
        ...options,
        signal: controller.signal,
      })
      clearTimeout(timeoutId)

      if (attempt > 1) {
        retryLog('OK', `Success on attempt ${attempt}`)
      }
      return response
    } catch (err) {
      clearTimeout(timeoutId)
      lastError = err

      if (err.name === 'AbortError') {
        retryLog('WARN', `Timeout after ${RETRY_TIMEOUT / 1000}s (cold start likely)`)
      } else {
        retryLog('WARN', `Failed: ${err.message}`)
      }

      if (attempt < RETRY_MAX) {
        await sleep(delay)
        delay *= RETRY_BACKOFF
      }
    }
  }

  retryLog('ERROR', `All ${RETRY_MAX} attempts failed`)
  throw lastError
}

// Environment detection
function detectEnvironment() {
  if (isLocal) return 'local'
  if (isCloud) return 'cloud'
  if (process.env.DOT_ENV === 'local') return 'local'
  if (process.env.DOT_ENV === 'cloud') return 'cloud'

  // Auto-detect: check if local Directus is running
  try {
    execSync('curl -sf --max-time 2 http://localhost:8055/server/health', {
      stdio: 'pipe',
    })
    return 'local'
  } catch {
    return 'cloud'
  }
}

const ENV = detectEnvironment()

// Configure URLs based on environment
const LOCAL_NUXT_URL = 'http://localhost:3000'
const CLOUD_NUXT_URL = 'https://ai.incomexsaigoncorp.vn'

const BASE_URL =
  process.env.NUXT_URL ||
  process.env.BASE_URL ||
  process.env.NUXT_PUBLIC_SITE_URL ||
  (ENV === 'local' ? LOCAL_NUXT_URL : CLOUD_NUXT_URL)

const AUTH_EMAIL = process.env.DIRECTUS_ADMIN_EMAIL || ''
const AUTH_PASSWORD = process.env.DIRECTUS_ADMIN_PASSWORD || ''
const LOGIN_PATH = process.env.DIRECTUS_LOGIN_PATH || '/api/directus/auth/login'
const HEALTH_PATH =
  process.env.DIRECTUS_HEALTH_PATH || '/api/directus/server/health'

function fmtStatus(status) {
  const colors_map = {
    pass: `${colors.green}PASS ${colors.reset}`,
    fail: `${colors.red}FAIL ${colors.reset}`,
    skip: `${colors.yellow}SKIP ${colors.reset}`,
  }
  return colors_map[status] || status.toUpperCase().padEnd(5, ' ')
}

async function checkDns(hostname) {
  const result = await dns.lookup(hostname)
  return `resolved to ${result.address}`
}

async function checkHttp(url, options = {}) {
  const response = await fetchWithRetry(url, options)
  return { status: response.status, headers: response.headers }
}

function printEnvironmentBanner() {
  const directusUrl =
    ENV === 'local'
      ? 'http://localhost:8055'
      : 'https://directus-test-pfne2mqwja-as.a.run.app'

  console.log('')
  if (ENV === 'local') {
    console.log(`${colors.green}${colors.bold}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${colors.reset}`)
    console.log(`${colors.green}${colors.bold}â”‚  ðŸŸ¢ LOCAL MODE                                      â”‚${colors.reset}`)
    console.log(`${colors.green}${colors.bold}â”‚     Nuxt:     ${BASE_URL.padEnd(37)}â”‚${colors.reset}`)
    console.log(`${colors.green}${colors.bold}â”‚     Directus: ${directusUrl.padEnd(37)}â”‚${colors.reset}`)
    console.log(`${colors.green}${colors.bold}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${colors.reset}`)
  } else {
    console.log(`${colors.red}${colors.bold}â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”${colors.reset}`)
    console.log(`${colors.red}${colors.bold}â”‚  ðŸ”´ CLOUD MODE (PRODUCTION)                         â”‚${colors.reset}`)
    console.log(`${colors.red}${colors.bold}â”‚     Nuxt:     ${BASE_URL.padEnd(37)}â”‚${colors.reset}`)
    console.log(`${colors.red}${colors.bold}â”‚     Directus: ${directusUrl}â”‚${colors.reset}`)
    console.log(`${colors.red}${colors.bold}â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜${colors.reset}`)
  }
  console.log('')
}

async function main() {
  const results = []
  const parsed = new URL(BASE_URL)

  console.log('DOT HEALTH CHECK')
  printEnvironmentBanner()

  if (isVerbose) {
    console.log(`Retry config: max=${RETRY_MAX}, timeout=${RETRY_TIMEOUT / 1000}s, delay=${RETRY_DELAY / 1000}s, backoff=${RETRY_BACKOFF}x`)
    console.log('')
  }

  console.log('-'.repeat(60))

  // Layer 1: Network (DNS)
  try {
    const detail = await checkDns(parsed.hostname)
    results.push({ layer: 'Network (DNS)', status: 'pass', detail })
  } catch (err) {
    results.push({
      layer: 'Network (DNS)',
      status: 'fail',
      detail: err.message || 'DNS lookup failed',
    })
  }

  // Layer 2: Web Server
  try {
    const res = await checkHttp(BASE_URL)
    const ok = res.status >= 200 && res.status < 400
    results.push({
      layer: 'Web Server',
      status: ok ? 'pass' : 'fail',
      detail: `HTTP ${res.status}`,
    })
  } catch (err) {
    results.push({
      layer: 'Web Server',
      status: 'fail',
      detail: err.message || 'Request failed (after retries)',
    })
  }

  // Layer 3: API Proxy
  try {
    const res = await checkHttp(`${BASE_URL}${HEALTH_PATH}`)
    const ok = res.status === 200
    results.push({
      layer: 'API Proxy',
      status: ok ? 'pass' : 'fail',
      detail: `HTTP ${res.status}`,
    })
  } catch (err) {
    results.push({
      layer: 'API Proxy',
      status: 'fail',
      detail: err.message || 'Request failed (after retries)',
    })
  }

  // Layer 4: Auth Flow
  if (!AUTH_EMAIL || !AUTH_PASSWORD) {
    results.push({
      layer: 'Auth Flow',
      status: 'skip',
      detail: 'Missing DIRECTUS_ADMIN_EMAIL or DIRECTUS_ADMIN_PASSWORD',
    })
  } else {
    try {
      const res = await checkHttp(`${BASE_URL}${LOGIN_PATH}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: AUTH_EMAIL,
          password: AUTH_PASSWORD,
          mode: 'session',
        }),
      })

      const setCookie = res.headers.get('set-cookie') || ''
      const hasSession =
        /directus_session_token=/i.test(setCookie) ||
        /__session=/i.test(setCookie)
      const hasSecure = /;\s*Secure/i.test(setCookie)

      const ok = res.status === 200 && hasSession && hasSecure
      const detailParts = [`HTTP ${res.status}`]
      detailParts.push(hasSession ? 'session cookie' : 'no session cookie')
      detailParts.push(hasSecure ? 'Secure ok' : 'Secure missing')

      results.push({
        layer: 'Auth Flow',
        status: ok ? 'pass' : 'fail',
        detail: detailParts.join(', '),
      })
    } catch (err) {
      results.push({
        layer: 'Auth Flow',
        status: 'fail',
        detail: err.message || 'Request failed (after retries)',
      })
    }
  }

  let hasFail = false
  let hasSkip = false

  for (const result of results) {
    if (result.status === 'fail') hasFail = true
    if (result.status === 'skip') hasSkip = true
    console.log(
      `${fmtStatus(result.status)} ${result.layer}: ${result.detail}`
    )
  }

  console.log('-'.repeat(60))
  if (hasFail) {
    console.log('SUMMARY: FAIL')
    process.exitCode = 1
  } else if (hasSkip) {
    console.log('SUMMARY: WARN (auth check skipped)')
  } else {
    console.log('SUMMARY: PASS')
  }
}

main().catch((err) => {
  console.error('FATAL:', err.message || err)
  process.exit(1)
})
