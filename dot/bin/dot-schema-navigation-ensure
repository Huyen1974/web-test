#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOT_AUTH="${SCRIPT_DIR}/dot-auth"

COLLECTION="navigation"
REQUIRED_FIELDS=(
  id
  items
)
PUBLIC_PERMISSION_FIELDS=(
  id
  items
)

log_info() {
  echo "[INFO] $1"
}

log_ok() {
  echo "[OK] $1"
}

log_warn() {
  echo "[WARN] $1"
}

log_skip() {
  echo "[SKIP] $1"
}

log_err() {
  echo "[ERR] $1" >&2
}

require_cmds() {
  for cmd in curl jq; do
    command -v "$cmd" >/dev/null 2>&1 || { log_err "Missing required command: $cmd"; exit 1; }
  done
}

api_request() {
  local method="$1"
  local url="$2"
  local data="${3-}"
  local resp

  if [[ -n "${data-}" ]]; then
    resp=$(curl -sS --globoff -X "$method" "$url" \
      -H "Authorization: Bearer $DOT_TOKEN" \
      -H "Content-Type: application/json" \
      -d "$data" \
      -w "\n%{http_code}")
  else
    resp=$(curl -sS --globoff -X "$method" "$url" \
      -H "Authorization: Bearer $DOT_TOKEN" \
      -w "\n%{http_code}")
  fi

  printf '%s' "$resp"
}

ensure_auth() {
  if [[ -z "${DOT_TOKEN:-}" ]]; then
    if [[ ! -f "$DOT_AUTH" ]]; then
      log_err "dot-auth not found at ${DOT_AUTH}"
      exit 1
    fi
    log_info "Authenticating with Directus..."
    # shellcheck source=/dev/null
    source "$DOT_AUTH" >/dev/null
  fi

  if [[ -z "${DOT_TOKEN:-}" ]]; then
    log_err "DOT_TOKEN is empty after authentication"
    exit 1
  fi
}

get_collection_meta() {
  local resp body code

  resp=$(api_request GET "${BASE_URL}/collections/${COLLECTION}")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" == "200" ]]; then
    echo "$body"
    return 0
  fi

  if [[ "$code" == "404" || "$code" == "403" ]]; then
    echo ""
    return 1
  fi

  log_err "Failed to read collection ${COLLECTION} (HTTP $code)"
  echo "$body" | head -c 200 >&2
  exit 1
}

is_singleton() {
  local body="$1"
  echo "$body" | jq -e '.data.meta.singleton == true' >/dev/null
}

is_singleton_empty() {
  local resp body code

  resp=$(api_request GET "${BASE_URL}/items/${COLLECTION}")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to read singleton ${COLLECTION} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  if echo "$body" | jq -e '.data == null' >/dev/null; then
    return 0
  fi

  if echo "$body" | jq -e '(.data | type == "object") and ((.data | keys) | length == 1) and (.data.id == null)' >/dev/null; then
    return 0
  fi

  if echo "$body" | jq -e '(.data | type == "object") and (all(.data[]; . == null))' >/dev/null; then
    return 0
  fi

  return 1
}

delete_collection() {
  local resp body code

  resp=$(api_request DELETE "${BASE_URL}/collections/${COLLECTION}")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "204" ]]; then
    log_err "Failed to delete collection ${COLLECTION} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  log_ok "Collection ${COLLECTION} deleted"
}

create_collection() {
  local payload resp body code

  payload=$(jq -nc --arg collection "$COLLECTION" '
    {
      collection: $collection,
      meta: {
        note: "Navigation menus (main, footer)",
        icon: "menu",
        singleton: false
      },
      schema: {},
      fields: [
        {
          field: "id",
          type: "string",
          meta: {
            interface: "input",
            special: null,
            required: true
          },
          schema: {
            is_primary_key: true,
            max_length: 50
          }
        }
      ]
    }
  ')

  log_info "Creating collection ${COLLECTION}"
  resp=$(api_request POST "${BASE_URL}/collections" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to create collection ${COLLECTION} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  log_ok "Collection ${COLLECTION} created"
}

list_fields() {
  local resp body code

  resp=$(api_request GET "${BASE_URL}/fields/${COLLECTION}")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to list fields for ${COLLECTION} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  echo "$body"
}

field_exists() {
  local fields_json="$1"
  local field_name="$2"

  echo "$fields_json" | jq -e --arg field "$field_name" '.data[]? | select(.field == $field)' >/dev/null
}

field_type() {
  local fields_json="$1"
  local field_name="$2"

  echo "$fields_json" | jq -r --arg field "$field_name" '.data[]? | select(.field == $field) | .type // empty'
}

create_items_field() {
  local payload resp body code

  payload=$(jq -nc '
    {
      field: "items",
      type: "json",
      meta: {
        interface: "list",
        special: ["cast-json"],
        note: "Navigation menu items"
      }
    }
  ')

  log_info "Creating field ${COLLECTION}.items"
  resp=$(api_request POST "${BASE_URL}/fields/${COLLECTION}" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to create field ${COLLECTION}.items (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  log_ok "Field ${COLLECTION}.items created"
}

item_exists() {
  local item_id="$1"
  local resp body code

  resp=$(api_request GET "${BASE_URL}/items/${COLLECTION}?filter[id][_eq]=${item_id}&limit=1")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to query ${COLLECTION} items (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  if echo "$body" | jq -e '.data | length > 0' >/dev/null; then
    return 0
  fi

  return 1
}

create_item() {
  local item_id="$1"
  local payload resp body code

  payload=$(jq -nc --arg id "$item_id" '{id: $id, items: []}')

  log_info "Creating ${COLLECTION} item ${item_id}"
  resp=$(api_request POST "${BASE_URL}/items/${COLLECTION}" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to create ${COLLECTION} item ${item_id} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  log_ok "Item ${item_id} created"
}

permission_fields_json() {
  printf '%s\n' "${PUBLIC_PERMISSION_FIELDS[@]}" | jq -R . | jq -s .
}

get_public_policy_id() {
  local resp body code policy_id

  resp=$(api_request GET "${BASE_URL}/policies")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    echo ""
    return 0
  fi

  policy_id=$(echo "$body" | jq -r '.data[]? | select(.name == "$t:public_label" or (.name | ascii_downcase | contains("public"))) | .id' | head -n 1)
  echo "$policy_id"
}

permission_payload() {
  local mode="$1"
  local scope_id="${2-}"
  local fields_json

  fields_json=$(permission_fields_json)

  if [[ "$mode" == "policy" ]]; then
    jq -nc --arg policy "$scope_id" --arg collection "$COLLECTION" --argjson fields "$fields_json" '
      {
        policy: $policy,
        collection: $collection,
        action: "read",
        fields: $fields,
        permissions: {},
        validation: {}
      }
    '
    return 0
  fi

  jq -nc --arg collection "$COLLECTION" --argjson fields "$fields_json" '
    {
      role: null,
      collection: $collection,
      action: "read",
      fields: $fields,
      permissions: {},
      validation: {}
    }
  '
}

permission_fields_ok() {
  local body="$1"
  local required_json

  if echo "$body" | jq -e '.data[0].fields == null or (.data[0].fields | length == 0) or (.data[0].fields | index("*"))' >/dev/null; then
    return 0
  fi

  required_json=$(permission_fields_json)
  echo "$body" | jq -e --argjson required "$required_json" '(.data[0].fields // []) as $fields | ($required - $fields) | length == 0' >/dev/null
}

create_permission() {
  local mode="$1"
  local scope_id="${2-}"
  local payload resp body code

  payload=$(permission_payload "$mode" "$scope_id")
  resp=$(api_request POST "${BASE_URL}/permissions" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to create Public read permission (HTTP $code)"
    echo "$body" | head -c 200 >&2
    return 1
  fi

  log_ok "Public read permission created"
  return 0
}

update_permission_fields() {
  local permission_id="$1"
  local fields_json payload resp body code

  fields_json=$(permission_fields_json)
  payload=$(jq -nc --argjson fields "$fields_json" '{fields:$fields, permissions:{}, validation:{}}')
  resp=$(api_request PATCH "${BASE_URL}/permissions/${permission_id}" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to update Public read permission (HTTP $code)"
    echo "$body" | head -c 200 >&2
    return 1
  fi

  log_ok "Public read permission updated"
  return 0
}

ensure_public_read() {
  local policy_id mode scope_id filter_query resp body code permission_id

  policy_id=$(get_public_policy_id)
  if [[ -n "$policy_id" ]]; then
    mode="policy"
    scope_id="$policy_id"
    filter_query="filter[policy][_eq]=${policy_id}"
  else
    mode="role"
    scope_id=""
    filter_query="filter[role][_null]=true"
  fi

  resp=$(api_request GET "${BASE_URL}/permissions?${filter_query}&filter[collection][_eq]=${COLLECTION}&filter[action][_eq]=read")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" == "200" ]]; then
    permission_id=$(echo "$body" | jq -r '.data[0].id // empty')
    if [[ -n "$permission_id" ]]; then
      if permission_fields_ok "$body"; then
        log_skip "Public read permission already configured"
        return 0
      fi

      log_warn "Public read permission exists but fields differ; updating"
      update_permission_fields "$permission_id" || return 1
      return 0
    fi

    log_info "Creating Public read permission"
    create_permission "$mode" "$scope_id" || return 1
    return 0
  fi

  if [[ "$code" == "403" ]]; then
    log_warn "Unable to read permissions (HTTP 403). Attempting to create Public read permission."
    create_permission "$mode" "$scope_id" || return 1
    return 0
  fi

  log_err "Failed to read permissions (HTTP $code)"
  echo "$body" | head -c 200 >&2
  return 1
}

verify_fields() {
  local fields_json missing=() field_type

  fields_json=$(list_fields)

  for field in "${REQUIRED_FIELDS[@]}"; do
    if ! field_exists "$fields_json" "$field"; then
      missing+=("$field")
      continue
    fi

    field_type=$(field_type "$fields_json" "$field")
    if [[ -z "$field_type" ]]; then
      missing+=("${field}:unknown")
    fi

    if [[ "$field" == "id" && "$field_type" != "string" ]]; then
      missing+=("id:type=${field_type}")
    fi

    if [[ "$field" == "items" && "$field_type" != "json" ]]; then
      missing+=("items:type=${field_type}")
    fi
  done

  if [[ "${#missing[@]}" -gt 0 ]]; then
    log_err "Field validation failed: ${missing[*]}"
    exit 1
  fi
}

ensure_items_field() {
  local fields_json

  fields_json=$(list_fields)
  if field_exists "$fields_json" "items"; then
    log_skip "Field ${COLLECTION}.items already exists"
    return 0
  fi

  create_items_field
}

ensure_items_records() {
  if item_exists "main"; then
    log_skip "Item main already exists"
  else
    create_item "main"
  fi

  if item_exists "footer"; then
    log_skip "Item footer already exists"
  else
    create_item "footer"
  fi
}

main() {
  local collection_body

  require_cmds
  BASE_URL="${DIRECTUS_BASE_URL:-https://directus-test-pfne2mqwja-as.a.run.app}"

  echo "========================================="
  echo "DOT Tool: Navigation Schema Ensure"
  echo "========================================="
  echo "Ensuring Directus navigation schema"
  echo "Target: ${BASE_URL}"
  echo ""

  ensure_auth

  collection_body=$(get_collection_meta || true)
  if [[ -n "$collection_body" ]]; then
    if is_singleton "$collection_body"; then
      log_info "Navigation is singleton. Verifying empty state..."
      if ! is_singleton_empty; then
        log_err "Navigation singleton is not empty. Refusing to delete."
        exit 1
      fi

      log_warn "Navigation singleton is empty; deleting to convert"
      delete_collection
      create_collection
    else
      log_skip "Navigation collection already converted"
    fi
  else
    log_info "Navigation collection not found; creating"
    create_collection
  fi

  log_info "Ensuring items field exists..."
  ensure_items_field

  log_info "Running field verification..."
  verify_fields

  log_info "Ensuring main/footer records exist..."
  ensure_items_records

  log_info "Ensuring Public read access..."
  if ! ensure_public_read; then
    log_err "Public read permission not configured. Please set Public READ on collection 'navigation'."
    exit 1
  fi

  log_ok "Collection navigation ready"

  echo ""
  echo "========================================="
  echo "DOT Tool: Navigation Schema Ensure - COMPLETE"
  echo "========================================="
}

main "$@"
