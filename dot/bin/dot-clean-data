#!/usr/bin/env node

/**
 * DOT Clean Data - Wipe business data while keeping schema intact
 *
 * SAFE: Only deletes data from business collections
 * FORBIDDEN: directus_* system tables, sites, tech_requests
 *
 * Usage:
 *   ./dot/bin/dot-clean-data [options]
 *
 * Options:
 *   --yes         Skip confirmation prompt
 *   --dry-run     Show what would be deleted without making changes
 *   --help        Show this help
 */

const path = require('path');
const fs = require('fs');
const https = require('https');
const http = require('http');
const readline = require('readline');

// Collections to clean (business data only)
// NEVER touch: directus_*, sites, tech_requests, globals
const CLEAN_COLLECTIONS = [
  'os_projects',
  'os_tasks',
  'os_invoices',
  'contacts',
  'agency_services',
  'agency_team_members',
  'agency_about',
];

const { execSync } = require('child_process');

// Parse arguments
const args = process.argv.slice(2);
const options = {
  help: args.includes('--help') || args.includes('-h'),
  yes: args.includes('--yes') || args.includes('-y'),
  dryRun: args.includes('--dry-run'),
  local: args.includes('--local'),
  cloud: args.includes('--cloud'),
};

if (options.help) {
  console.log(`
DOT Clean Data - Wipe business data while keeping schema intact

Usage:
  ./dot/bin/dot-clean-data [options]

Options:
  --local       Use local development environment
  --cloud       Use cloud/production environment (default)
  --yes, -y     Skip confirmation prompt
  --dry-run     Show what would be deleted without making changes
  --help, -h    Show this help

Collections that will be wiped:
  ${CLEAN_COLLECTIONS.join(', ')}

Collections that are PROTECTED (never touched):
  directus_*, sites, tech_requests, globals

Environment Variables:
  DIRECTUS_URL            Directus API URL
  DIRECTUS_ADMIN_EMAIL    Admin email
  DIRECTUS_ADMIN_PASSWORD Admin password
`);
  process.exit(0);
}

// Environment detection
function detectEnvironment() {
  if (options.local) return 'local';
  if (options.cloud) return 'cloud';
  if (process.env.DOT_ENV === 'local') return 'local';
  if (process.env.DOT_ENV === 'cloud') return 'cloud';

  // Auto-detect
  try {
    execSync('curl -sf --max-time 1 http://localhost:8055/server/health', {
      stdio: 'pipe',
    });
    return 'local';
  } catch {
    return 'cloud';
  }
}

const ENV = detectEnvironment();
const LOCAL_DIRECTUS_URL = 'http://localhost:8055';
const CLOUD_DIRECTUS_URL = 'https://directus-test-pfne2mqwja-as.a.run.app';

// Print environment banner
function printEnvironmentBanner(directusUrl) {
  console.log('');
  if (ENV === 'local') {
    console.log('\x1b[32m\x1b[1mâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\x1b[0m');
    console.log('\x1b[32m\x1b[1mâ”‚  ðŸŸ¢ LOCAL MODE                                      â”‚\x1b[0m');
    console.log(`\x1b[32m\x1b[1mâ”‚     Directus: ${directusUrl.padEnd(37)}â”‚\x1b[0m`);
    console.log('\x1b[32m\x1b[1mâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\x1b[0m');
  } else {
    console.log('\x1b[31m\x1b[1mâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\x1b[0m');
    console.log('\x1b[31m\x1b[1mâ”‚  ðŸ”´ CLOUD MODE (PRODUCTION)                         â”‚\x1b[0m');
    console.log(`\x1b[31m\x1b[1mâ”‚     Directus: ${directusUrl}â”‚\x1b[0m`);
    console.log('\x1b[31m\x1b[1mâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\x1b[0m');
    console.log('');
    console.log('\x1b[31m\x1b[1mâš ï¸  WARNING: This is a DESTRUCTIVE operation on PRODUCTION!\x1b[0m');
    console.log('\x1b[31m   Data will be permanently deleted.\x1b[0m');
  }
  console.log('');
}

// Load credentials
function loadConfig() {
  const configDir = path.resolve(__dirname, '../config');
  const localPath = path.resolve(configDir, 'credentials.local.json');
  const projectRoot = path.resolve(__dirname, '../..');
  const envLocalPath = path.resolve(projectRoot, '.env.local');

  // Determine default URL based on environment
  const defaultUrl = ENV === 'local' ? LOCAL_DIRECTUS_URL : CLOUD_DIRECTUS_URL;

  let config = {
    directusUrl: process.env.DIRECTUS_URL || defaultUrl,
    email: process.env.DIRECTUS_ADMIN_EMAIL || 'admin@example.com',
    password: process.env.DIRECTUS_ADMIN_PASSWORD,
  };

  // For local mode, try .env.local first
  if (ENV === 'local' && fs.existsSync(envLocalPath)) {
    try {
      const envContent = fs.readFileSync(envLocalPath, 'utf-8');
      const emailMatch = envContent.match(/^DIRECTUS_ADMIN_EMAIL=(.+)$/m);
      const passMatch = envContent.match(/^DIRECTUS_ADMIN_PASSWORD=(.+)$/m);
      if (emailMatch) config.email = emailMatch[1];
      if (passMatch) config.password = passMatch[1];
    } catch (e) {
      // Ignore
    }
  }

  // Try credentials.local.json as fallback
  if (!config.password && fs.existsSync(localPath)) {
    try {
      const creds = JSON.parse(fs.readFileSync(localPath, 'utf-8'));
      const profile = creds.profiles?.[0];
      if (profile) {
        config.email = config.email || profile.username;
        config.password = config.password || profile.password;
        config.directusUrl = config.directusUrl || creds.directusUrl;
      }
    } catch (e) {
      // Ignore parse errors
    }
  }

  if (!config.password) {
    console.error('Error: DIRECTUS_ADMIN_PASSWORD is required');
    console.error('For local mode: ensure .env.local exists');
    console.error('For cloud mode: set DIRECTUS_ADMIN_PASSWORD env var');
    process.exit(1);
  }

  return config;
}

// HTTP request helper
function request(url, options = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(url);
    const client = urlObj.protocol === 'https:' ? https : http;

    const req = client.request(url, {
      method: options.method || 'GET',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers,
      },
    }, (res) => {
      let data = '';
      res.on('data', chunk => data += chunk);
      res.on('end', () => {
        try {
          resolve({ status: res.statusCode, data: JSON.parse(data) });
        } catch {
          resolve({ status: res.statusCode, data });
        }
      });
    });

    req.on('error', reject);
    if (options.body) req.write(JSON.stringify(options.body));
    req.end();
  });
}

// Prompt for confirmation
function confirm(question) {
  return new Promise((resolve) => {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });
    rl.question(question, (answer) => {
      rl.close();
      resolve(answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes');
    });
  });
}

async function main() {
  const config = loadConfig();

  console.log('\n\x1b[36m\x1b[1m  DOT CLEAN DATA\x1b[0m');
  printEnvironmentBanner(config.directusUrl);
  if (options.dryRun) {
    console.log('\x1b[33m[DRY-RUN MODE]\x1b[0m No data will be deleted\n');
  }

  // Authenticate
  console.log('\x1b[33m[AUTH]\x1b[0m Logging in...');
  const authRes = await request(`${config.directusUrl}/auth/login`, {
    method: 'POST',
    body: { email: config.email, password: config.password },
  });

  if (!authRes.data?.data?.access_token) {
    console.error('\x1b[31m[ERROR]\x1b[0m Authentication failed');
    process.exit(1);
  }

  const token = authRes.data.data.access_token;
  console.log('\x1b[32m[AUTH]\x1b[0m Success\n');

  // Get available collections
  const collectionsRes = await request(`${config.directusUrl}/collections`, {
    headers: { Authorization: `Bearer ${token}` },
  });

  const availableCollections = collectionsRes.data?.data?.map(c => c.collection) || [];

  // Count items in each collection
  console.log('\x1b[1mCollections to clean:\x1b[0m\n');
  const toClean = [];

  for (const collection of CLEAN_COLLECTIONS) {
    if (!availableCollections.includes(collection)) {
      console.log(`  \x1b[33m[SKIP]\x1b[0m ${collection} - not found`);
      continue;
    }

    const countRes = await request(`${config.directusUrl}/items/${collection}?aggregate[count]=*`, {
      headers: { Authorization: `Bearer ${token}` },
    });

    const count = countRes.data?.data?.[0]?.count || 0;
    console.log(`  ${collection}: ${count} items`);
    if (count > 0) {
      toClean.push({ collection, count });
    }
  }

  if (toClean.length === 0) {
    console.log('\n\x1b[32m[OK]\x1b[0m No data to clean. Collections are already empty.');
    process.exit(0);
  }

  const totalItems = toClean.reduce((sum, c) => sum + parseInt(c.count), 0);
  console.log(`\n\x1b[1mTotal:\x1b[0m ${totalItems} items in ${toClean.length} collections\n`);

  // Confirm
  if (!options.yes && !options.dryRun) {
    const confirmed = await confirm('\x1b[31mAre you sure you want to delete all this data? (y/n): \x1b[0m');
    if (!confirmed) {
      console.log('\n\x1b[33m[CANCELLED]\x1b[0m No data was deleted.');
      process.exit(0);
    }
    console.log('');
  }

  // Delete data
  const results = { success: [], failed: [] };

  for (const { collection, count } of toClean) {
    if (options.dryRun) {
      console.log(`\x1b[33m[DRY-RUN]\x1b[0m Would delete ${count} items from ${collection}`);
      results.success.push(collection);
      continue;
    }

    try {
      // Get all item IDs
      const itemsRes = await request(`${config.directusUrl}/items/${collection}?fields=id&limit=-1`, {
        headers: { Authorization: `Bearer ${token}` },
      });

      const ids = itemsRes.data?.data?.map(item => item.id) || [];

      if (ids.length > 0) {
        // Delete items one by one (Directus bulk delete can be finicky)
        let deleted = 0;
        let failed = 0;

        for (const id of ids) {
          const deleteRes = await request(`${config.directusUrl}/items/${collection}/${id}`, {
            method: 'DELETE',
            headers: { Authorization: `Bearer ${token}` },
          });

          if (deleteRes.status === 204 || deleteRes.status === 200) {
            deleted++;
          } else {
            failed++;
          }
        }

        if (failed === 0) {
          console.log(`\x1b[32m[OK]\x1b[0m ${collection} - deleted ${deleted} items`);
          results.success.push(collection);
        } else {
          console.log(`\x1b[33m[PARTIAL]\x1b[0m ${collection} - deleted ${deleted}, failed ${failed}`);
          if (deleted > 0) results.success.push(collection);
          else results.failed.push(collection);
        }
      }
    } catch (err) {
      console.log(`\x1b[31m[FAIL]\x1b[0m ${collection} - ${err.message}`);
      results.failed.push(collection);
    }
  }

  // Summary
  console.log('\n\x1b[1m SUMMARY\x1b[0m\n');
  console.log(`\x1b[32mCleaned:\x1b[0m ${results.success.length} collections`);
  console.log(`\x1b[31mFailed:\x1b[0m ${results.failed.length} collections`);

  if (!options.dryRun) {
    console.log(`\nTimestamp: ${new Date().toISOString()}`);
  }

  if (results.failed.length > 0) {
    process.exit(1);
  }
}

main().catch(err => {
  console.error('\x1b[31m[ERROR]\x1b[0m', err.message);
  process.exit(1);
});
