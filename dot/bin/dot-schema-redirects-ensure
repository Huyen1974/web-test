#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
DOT_AUTH="${SCRIPT_DIR}/dot-auth"

COLLECTION="redirects"
REQUIRED_FIELDS=(
  from
  to
  status_code
  enabled
  sort
  note
)
PERMISSION_FIELDS=(
  id
  from
  to
  status_code
  enabled
  sort
  note
)

log_info() {
  echo "[INFO] $1"
}

log_ok() {
  echo "[OK] $1"
}

log_warn() {
  echo "[WARN] $1"
}

log_skip() {
  echo "[SKIP] $1"
}

log_err() {
  echo "[ERR] $1" >&2
}

require_cmds() {
  for cmd in curl jq; do
    command -v "$cmd" >/dev/null 2>&1 || { log_err "Missing required command: $cmd"; exit 1; }
  done
}

api_request() {
  local method="$1"
  local url="$2"
  local data="${3-}"
  local resp

  if [[ -n "${data-}" ]]; then
    resp=$(curl -sS --globoff -X "$method" "$url" \
      -H "Authorization: Bearer $DOT_TOKEN" \
      -H "Content-Type: application/json" \
      -d "$data" \
      -w "\n%{http_code}")
  else
    resp=$(curl -sS --globoff -X "$method" "$url" \
      -H "Authorization: Bearer $DOT_TOKEN" \
      -w "\n%{http_code}")
  fi

  printf '%s' "$resp"
}

ensure_auth() {
  if [[ -z "${DOT_TOKEN:-}" ]]; then
    if [[ ! -f "$DOT_AUTH" ]]; then
      log_err "dot-auth not found at ${DOT_AUTH}"
      exit 1
    fi
    log_info "Authenticating with Directus..."
    # shellcheck source=/dev/null
    source "$DOT_AUTH" >/dev/null
  fi

  if [[ -z "${DOT_TOKEN:-}" ]]; then
    log_err "DOT_TOKEN is empty after authentication"
    exit 1
  fi
}

collection_exists() {
  local resp body code

  resp=$(api_request GET "${BASE_URL}/collections")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to list collections (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  if echo "$body" | jq -e --arg collection "$COLLECTION" '.data[]? | select(.collection == $collection)' >/dev/null; then
    return 0
  fi
  return 1
}

field_exists() {
  local field_name="$1"
  local resp body code

  resp=$(api_request GET "${BASE_URL}/fields/${COLLECTION}")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to list fields for ${COLLECTION} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  if echo "$body" | jq -e --arg field "$field_name" '.data[]? | select(.field == $field)' >/dev/null; then
    return 0
  fi
  return 1
}

get_field_type() {
  local field_name="$1"
  local resp body code

  resp=$(api_request GET "${BASE_URL}/fields/${COLLECTION}")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to list fields for ${COLLECTION} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  echo "$body" | jq -r --arg field "$field_name" '.data[]? | select(.field == $field) | .type // empty'
}

field_payload() {
  case "$1" in
    from)
      cat <<'JSON'
{"field":"from","type":"string","meta":{"required":true},"schema":{"is_nullable":false}}
JSON
      ;;
    to)
      cat <<'JSON'
{"field":"to","type":"string","meta":{"required":true},"schema":{"is_nullable":false}}
JSON
      ;;
    status_code)
      cat <<'JSON'
{"field":"status_code","type":"integer","meta":{"required":false},"schema":{"is_nullable":true,"default_value":301}}
JSON
      ;;
    enabled)
      cat <<'JSON'
{"field":"enabled","type":"boolean","meta":{"required":false},"schema":{"is_nullable":false,"default_value":true}}
JSON
      ;;
    sort)
      cat <<'JSON'
{"field":"sort","type":"integer","meta":{"required":false},"schema":{"is_nullable":true}}
JSON
      ;;
    note)
      cat <<'JSON'
{"field":"note","type":"text","meta":{"required":false},"schema":{"is_nullable":true}}
JSON
      ;;
    *)
      return 1
      ;;
  esac
}

create_collection() {
  local payload resp body code

  payload=$(jq -nc --arg collection "$COLLECTION" --arg note "Created by DOT redirects schema ensure" '
    {
      collection: $collection,
      schema: {},
      meta: { note: $note },
      fields: [
        { field: "id", type: "uuid", meta: { required: true }, schema: { is_primary_key: true, is_nullable: false } }
      ]
    }
  ')

  log_info "Creating collection ${COLLECTION}"
  resp=$(api_request POST "${BASE_URL}/collections" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to create collection ${COLLECTION} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  log_ok "Collection ${COLLECTION} created"
}

create_field() {
  local field_name="$1"
  local payload resp body code

  payload=$(field_payload "$field_name")
  log_info "Creating field ${COLLECTION}.${field_name}"
  resp=$(api_request POST "${BASE_URL}/fields/${COLLECTION}" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to create field ${COLLECTION}.${field_name} (HTTP $code)"
    echo "$body" | head -c 200 >&2
    exit 1
  fi

  log_ok "Field ${COLLECTION}.${field_name} created"
}

field_type_ok() {
  local field_name="$1"
  local field_type="$2"

  case "$field_name" in
    from|to)
      [[ "$field_type" == "string" ]]
      ;;
    status_code|sort)
      [[ "$field_type" == "integer" ]]
      ;;
    enabled)
      [[ "$field_type" == "boolean" ]]
      ;;
    note)
      [[ "$field_type" == "text" ]]
      ;;
    *)
      return 1
      ;;
  esac
}

get_public_policy_id() {
  local resp body code policy_id

  resp=$(api_request GET "${BASE_URL}/policies")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    echo ""
    return 0
  fi

  policy_id=$(echo "$body" | jq -r '.data[]? | select(.name == "$t:public_label" or (.name | ascii_downcase | contains("public"))) | .id' | head -n 1)
  echo "$policy_id"
}

permission_fields_json() {
  printf '%s\n' "${PERMISSION_FIELDS[@]}" | jq -R . | jq -s .
}

permission_payload() {
  local mode="$1"
  local scope_id="${2-}"
  local fields_json

  fields_json=$(permission_fields_json)
  if [[ "$mode" == "policy" ]]; then
    jq -nc --arg policy "$scope_id" --arg collection "$COLLECTION" --argjson fields "$fields_json" '
      {
        policy: $policy,
        collection: $collection,
        action: "read",
        fields: $fields,
        permissions: {},
        validation: {}
      }
    '
    return 0
  fi

  jq -nc --arg collection "$COLLECTION" --argjson fields "$fields_json" '
    {
      collection: $collection,
      action: "read",
      role: null,
      fields: $fields,
      permissions: {},
      validation: {}
    }
  '
}

permission_fields_ok() {
  local body="$1"
  local required_json

  if echo "$body" | jq -e '.data[0].fields == null or (.data[0].fields | length == 0) or (.data[0].fields | index("*"))' >/dev/null; then
    return 0
  fi

  required_json=$(permission_fields_json)
  echo "$body" | jq -e --argjson required "$required_json" '(.data[0].fields // []) as $fields | ($required - $fields) | length == 0' >/dev/null
}

create_permission() {
  local mode="$1"
  local scope_id="${2-}"
  local payload resp body code

  payload=$(permission_payload "$mode" "$scope_id")
  resp=$(api_request POST "${BASE_URL}/permissions" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to create Public read permission (HTTP $code)"
    echo "$body" | head -c 200 >&2
    return 1
  fi

  log_ok "Public read permission created"
  return 0
}

update_permission_fields() {
  local permission_id="$1"
  local fields_json payload resp body code

  fields_json=$(permission_fields_json)
  payload=$(jq -nc --argjson fields "$fields_json" '{fields:$fields, permissions:{}, validation:{}}')
  resp=$(api_request PATCH "${BASE_URL}/permissions/${permission_id}" "$payload")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" != "200" ]]; then
    log_err "Failed to update Public read permission (HTTP $code)"
    echo "$body" | head -c 200 >&2
    return 1
  fi

  log_ok "Public read permission updated"
  return 0
}

ensure_public_read() {
  local policy_id resp body code permission_id mode scope_id filter_query

  policy_id=$(get_public_policy_id)
  if [[ -n "$policy_id" ]]; then
    mode="policy"
    scope_id="$policy_id"
    filter_query="filter[policy][_eq]=${policy_id}"
  else
    mode="role"
    scope_id=""
    filter_query="filter[role][_null]=true"
  fi

  resp=$(api_request GET "${BASE_URL}/permissions?${filter_query}&filter[collection][_eq]=${COLLECTION}&filter[action][_eq]=read")
  body="${resp%$'\n'*}"
  code="${resp##*$'\n'}"

  if [[ "$code" == "200" ]]; then
    permission_id=$(echo "$body" | jq -r '.data[0].id // empty')
    if [[ -n "$permission_id" ]]; then
      if permission_fields_ok "$body"; then
        log_skip "Public read permission already configured"
        return 0
      fi

      log_warn "Public read permission exists but fields differ; updating"
      update_permission_fields "$permission_id" || return 1
      return 0
    fi

    log_info "Creating Public read permission"
    create_permission "$mode" "$scope_id" || return 1
    return 0
  fi

  if [[ "$code" == "403" ]]; then
    log_warn "Unable to read permissions (HTTP 403). Attempting to create Public read permission."
    create_permission "$mode" "$scope_id" || return 1
    return 0
  fi

  log_err "Failed to read permissions (HTTP $code)"
  echo "$body" | head -c 200 >&2
  return 1
}

verify_fields() {
  local mismatches=()
  local field_type

  for field in "${REQUIRED_FIELDS[@]}"; do
    if ! field_exists "$field"; then
      mismatches+=("${field}:missing")
      continue
    fi

    field_type=$(get_field_type "$field")
    if [[ -z "$field_type" ]]; then
      mismatches+=("${field}:unknown")
      continue
    fi

    if ! field_type_ok "$field" "$field_type"; then
      mismatches+=("${field}:type=${field_type}")
    fi
  done

  if [[ "${#mismatches[@]}" -gt 0 ]]; then
    log_err "Field validation failed: ${mismatches[*]}"
    exit 1
  fi
}

main() {
  require_cmds
  BASE_URL="${DIRECTUS_BASE_URL:-https://directus-test-pfne2mqwja-as.a.run.app}"

  echo "========================================="
  echo "DOT Tool: Redirects Schema Ensure"
  echo "========================================="
  echo "Ensuring Directus redirects schema"
  echo "Target: ${BASE_URL}"
  echo ""

  ensure_auth

  if collection_exists; then
    log_skip "Collection '${COLLECTION}' already exists"
  else
    create_collection
  fi

  log_info "Ensuring required fields exist..."
  for field in "${REQUIRED_FIELDS[@]}"; do
    if field_exists "$field"; then
      log_skip "Field ${COLLECTION}.${field} already exists"
    else
      create_field "$field"
    fi
  done

  log_info "Running final verification..."
  verify_fields
  log_info "Ensuring Public read access..."
  if ! ensure_public_read; then
    log_err "Public read permission not configured. Please set Public READ on collection 'redirects'."
    exit 1
  fi
  log_ok "Collection redirects ready"

  echo ""
  echo "========================================="
  echo "DOT Tool: Redirects Schema Ensure - COMPLETE"
  echo "========================================="
}

main "$@"
